Current Plan:
-> Replace Moves and anything by ConsecutiveNode of Leaf
-> Replace other parameters by leafs (coords, colors, counts)
-> Replace Root by a product type?
-> Create Transformati


Issue:
-> speed: loss filter?
-> There is indeterminism in the code, I don't know why


#### TO DO

Add Rect(Var(0), Var(0)) by default?

-> Improve coding so similar elments for categories,
-> Improve the code base
-> switch to the Freeman.py functions / simplify the structure
-> For branching structure implement finite recursion through a Y combinator:
Y node 3= node Y node 2 , (maybe repeat (branch) ?)
to solve structure like [3, [3, [3, ...,6], 6], 6]
Repeat(branch()

AST Map simplification is giga costly

###
What to do when color info make the thing make the wrong association ? :(
Element associated to  s_4((0, 0), {4}) :
For input 1: element  s_0((0, 1), {4})


Do You WANT bi symbolic node with parameters of DIFFERENT types?


-> The brain loves finding square in shapes
-> Immediate coverage is not overlapping
-> The squares will be as big as possible, given the area in them is maxxed

____
Full Bias: just put a language to compress repetitions and memorize nested structures
When going to the variance side, you need to modify the language by adding primitives

Full Variance: Pure statistical memorization of patterns, in a kind of universal code.
You don't even need to do it on programm space, you can just doing on string / literal space.

Middle ground: Symbolization: you memorize reppeting patterns,
but allow these patterns to be functional parts of the language.

--------
Maybe the solution is to coma back to the basic, and describe objects by their frontier:
d07ae81c.json
You have a freeman code chain for each boundary. If there are intersection like cross,
you decompose it into the simplest code chains
Combined with backgroudn normalisation the bord is sufficient

-> At intersection apply the law of continuity
It should also work for the olympic node / Prägnanz

-> The right marginalization provids grouping

-> Optimization will provide symmetry

Gestalt principles:
-> Figure/Ground: background normalisation (see Rubin's vase)

-> What will be lacking is closure

####
Correct the bug froùm
e509e548.json


Colors + rectangles -> Marginalization by the closed sets

-> If the jaccard detects a perfect alignement, can the aligned part of the input be tagged as ('output')
and conversely in the output?
See 007bbfb7.json

Fuzzy equivalence relations on product shapes?
-> Rectangular
-> Circular


{5}->(0, 0):Rect(12, 12) < {{7}->(1, 2):Rect(2, 2)}U{{0}->(11, 5):(0)*{8}[((0)*{3}3(2)*{3}3)*{3}[(2)*{6}(1)*{5}223032303230,(0)*{3}],5(1)*{4}[(2)*{7}3032303[(0)*{5}(1)*{3}233,2],(0)*{4}]]}U{{8}->(5, 7):Rect(3, 3)}U{{6}->(8, 2):None}
{0}->(0, 0):Rect(12, 12) < {{5}->(4, 6):(2)*{4}(3)*{4}(0)*{4}(1)*{3}}U{{5}->(0, 1):(2)*{3}(3)*{3}(0)*{3}11}U{{5}->(7, 1):2233001}
####
{3}->(10, 0):((0)*{4}Rect(2, 1)(Rect(1, 2))*{4}Rect(2, 1))*{2}(0)*{4}
(2)*{4}3(0)*{4}3)*{2}(2)*{4}
(2222 3 0000 3) * 2 2222

NodeList([rect_to_moves(5, 5)])

-> For symbolization: replace also if the entire unfolded sequence is the same to avoid repeat(, 2) effects
Problem: if a shape is not really in the dataset it can struggle to learn it like squares
-> Encode it at pre-made symbols:
Basic Symbols:
Var(0)Var(0)Var(1)Var(0)
Var(0)3Var(1)3 (S2(6) s1(6))

Carré (nxn)
None 1x1
230 (2x2)
22300322 (3x3)
222300032223000: ((2)*{3} 3 (0){3}){2} (4x4)
22223000322223000032222 2{4} (3 0{4} 3 2{4}) (5x5)

Repeat(NodeList(Repeat(Moves('2'), c1), Moves('3), Repeat(Moves('0'), c2)), Moves('3')), c3)

for row in range(height):
    + 2

Rect (n, m)
2 (2x1)
3 (1x2)
22300 (2x3)
2{3} 3 0{3} (2x4)
Repeat(Moves('2'), c1), Moves('3'), Repeat(Moves('0'), c2) if c1==c2:
    return rect(2,c1+1)

2 3 0 (2x2)

2 3 0 3 2 (3x2)

2 3 0 3 2 3 0 (4x2)
2(3 0)(3 2){h//2}(3 2)if h%2==1


hollow square n
2{n} 3{n} 0{n} 1{n-1}

Cross (n):
[0, 1, 2, 3]
[00, 11, 22, 33]
[0{n}, 1{n}, 2{n}, 3{n}]



pair:
((2){w-1} 3 (0){w-1} 3){h//2}
impair:
(2){w-1} (3 (2){w-1} 3 (0){w-1}){h//2}



# Normalisation can make some unions very far in program space, notably if the morphology to recognize is complicated
#in its subrect, because it is getting normalized away.
----> You NEED to TRY BOTH VERSIONS, EACH TIME

s_2(6) 3 s2(6) 3
O>>>>>>
<<<<<<v
v

3 s_2(4) 3 s_1(4)
O
v>>>>
<<<<v

s2: (2)*{Var(0)} s1: (0)*{Var(0)}

rect(height, width) (2*{var(0)} 3 0*{var(0)} 3)*{var(1)} where var(0) = height, var(1) = width/2
refs = Repeat(UnionNode(Repeat(Moves("2"), Var(0)), 3, Repeat(Moves("0"), Var(0), 3), Var(1))

####
[V] Understand why the lattice n°3 is represented differently from number 1 and number 2
[V] Optimal scanning with sub unions
[V] Union with backgrounds
[V] Hit-or-miss/jaccard for colored grid to have node distance
[] Creation of a "Output" space and "Input" space with a way to project the input to the output
Idea -> Things should be as closed to the identity as possible
[X] make unions even more compressed with sets of programs and sets of params
[] resolve the repeat issue : (Var)*{3}(0) == (0)*{Var}(3)
[V] Have a codes and a codes_shifted druign symbolization, as code_shifted should be used to write unions

[V] See issue with problem 1: why not s6?

->> Avoid over_symbolization, maybe symbols shoukld not be able to have bisymbols as params
som symbolization add nothing it leads to this: s_3  < { s_21 } ->  s_3  < { s_21 }
Or maybe it's ok with the right program distance

[] to find the programs of the union: jaccard dist to the previously learned invariants?
For problem 1
Unshifted input: { s_17((1, 5)) } -> { s_17((1, 1)) }U{ s_6((0, 0)) }
Shifted input: { s_17((0, 0)) } -> { s_17((1, 1)) }U{ s_6((0, 0)) }

also issue for problem 2:
For problem 2
Unshifted input: { s_9({8}) } -> { s_9({8}) }U{ s_1({3}) }
Shifted input: {{8}->(0, 0):None} -> { s_9({8}) }U{ s_1({3}) }

#### AIM: Get JACCARD to 0
Note it's an heuristic / distance measure because it's the latent program that needs alignement
